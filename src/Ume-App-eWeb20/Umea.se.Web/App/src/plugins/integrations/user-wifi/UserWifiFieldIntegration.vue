<template>
	<div>
		<admin-switch
			v-if="isTable"
			:id="props.field.guid + 'user-table-wifi'"
			v-model="tableUseIntegration"
			:label="
				$t(
					'component.adminIntegrationUserWifiConnections.dataTableField'
				)
			"
			:help-text="
				$t(
					'component.adminIntegrationUserWifiConnections.dataTableFieldHelpText'
				)
			"
		/>
		<p v-else-if="insideTableWithoutActiveIntegration">
			{{
				$t(
					'component.adminIntegrationUserWifiConnections.insideTableWithoutIntegration'
				)
			}}
		</p>
		<!-- Elev wifi field (utdata) -->
		<admin-select-list
			v-else
			:id="props.field.guid + 'user-wifi'"
			:label="
				$t('component.adminIntegrationUserWifiConnections.dataField')
			"
			:help-text="
				$t(
					'component.adminIntegrationUserWifiConnections.dataFieldHelpText'
				)
			"
			v-model="listFieldItemProp"
			:items="dataSourceSchemaProperties"
		/>

		<div v-if="props.field.type === FormFieldType.TextBox">
			<admin-switch
				id="generatePassword"
				v-model="autoGeneratedPassword"
				:label="
					$t('app.admin.field.checkboxForAutoGeneratedPasswordText')
				"
				:help-text="
					$t(
						'app.admin.field.checkboxForAutoGeneratedPasswordDescription'
					)
				"
			/>

			<span v-if="autoGeneratedPassword">
				<admin-text-box
					id="passwordLength"
					v-model="passwordLength"
					:label="$t('app.admin.field.passwordLength')"
				/>
				<admin-select-list
					id="passwordSpecialCharacters"
					v-model="selectedPasswordSpecialCharacters"
					:items="passwordSpecialCharacters"
					item-value="id"
					:label="$t('app.admin.field.passwordSpecialCharacters')"
				/>
			</span>
		</div>
	</div>
</template>

<script setup lang="ts">
import AdminSwitch from '@/components/field/admin/AdminSwitch.vue';
import AdminTextBox from '@/components/field/admin/AdminTextBox.vue';
import AdminSelectList from '@/components/field/admin/AdminSelectList.vue';
import {
	AvailableIntegration,
	FormFieldType,
	MutationType,
} from '@/models/Enums';
import {
	IFormField,
	IFormIntegration,
	IItem,
	IRootState,
} from '@/models/IForm';
import {
	IDataServicePluginRootStore,
	IDataSourceConnector,
} from '@/plugins/dataService/models';
import { computed, PropType, inject } from 'vue';
import { useI18n } from 'vue-i18n';
import { useStore } from 'vuex';

const props = defineProps({
	integration: {
		type: Object as PropType<IFormIntegration>,
		required: true,
	},
	field: {
		type: Object as PropType<IFormField>,
		required: true,
	},
});

const { t } = useI18n();

interface WifiRootState extends IRootState {
	dataServiceOutPutPlugin: IDataServicePluginRootStore;
}
const store = useStore<WifiRootState>();

const isTable = computed(() => props.field.type === FormFieldType.Table);

const dataSourceConnector = inject(
	'$dataSourceConnector'
) as IDataSourceConnector;

const selectedDataSourceSpecOutPut = computed(() => {
	if (store.state.dataServiceOutPutPlugin.dataSourceSpecsOutPut) {
		return store.state.dataServiceOutPutPlugin.dataSourceSpecsOutPut.find(
			(d) => d.dataSourceName === AvailableIntegration.UserWifiConnections
		);
	}
	return null;
});

const dataSourceSchemaProperties = computed(() => {
	if (selectedDataSourceSpecOutPut.value) {
		return [
			{
				title: t(
					'component.adminIntegrationUserWifiConnections.listDefaultTitle'
				),
				value: '',
			},
		].concat(
			Object.keys(selectedDataSourceSpecOutPut.value.schema)
				.sort()
				.map((key) => {
					const exampleValue =
						selectedDataSourceSpecOutPut.value?.exampleData[key];
					const example =
						typeof exampleValue === 'string' && exampleValue
							? ' (t.ex. ' + exampleValue + ')'
							: '';
					return {
						title: key + example,
						value: key,
					};
				})
		);
	}
	return [];
});

const listFieldItemProp = computed({
	get: () => {
		const dataSourceConnection = dataSourceConnector.getOutPutConnection(
			props.field
		);
		return dataSourceConnection
			? dataSourceConnection?.options.itemProperty
			: '';
	},
	set: (itemProperty: string | undefined) => {
		if (!itemProperty) {
			dataSourceConnector.removeOutPutConnection(props.field);
		} else {
			const dataSourceConnection =
				dataSourceConnector.getOutPutConnection(props.field);

			// update the datasource connection
			dataSourceConnector.setOutPutConnection(props.field, {
				...dataSourceConnection,
				dataSourceName: AvailableIntegration.UserWifiConnections,
				options: { itemProperty },
			});
		}
	},
});

// If the field is inside a table that is not connected to the integration
const insideTableWithoutActiveIntegration = computed(() => {
	if (props.field.fieldOptions.tableGuid) {
		const stepIndex = (store.state.admin?.activeStep ?? 1) - 1;
		const tableField = store.state.form?.attributes.steps[
			stepIndex
		].fields.find(
			(field) => field.guid === props.field.fieldOptions.tableGuid
		);
		if (tableField) {
			const dataSourceConnection =
				dataSourceConnector.getOutPutConnection(tableField);

			return !dataSourceConnection;
		}
	}
	return false;
});

// Connect/disconnect table to the elev wifi integration
const tableUseIntegration = computed({
	get: () => {
		const dataSourceConnection = dataSourceConnector.getOutPutConnection(
			props.field
		);
		return !!dataSourceConnection;
	},
	set: (active: boolean) => {
		if (!active) {
			dataSourceConnector.removeOutPutConnection(props.field);
		} else {
			const dataSourceConnection =
				dataSourceConnector.getOutPutConnection(props.field);

			// update the datasource connection
			dataSourceConnector.setOutPutConnection(props.field, {
				...dataSourceConnection,
				dataSourceName: AvailableIntegration.UserWifiConnections,
				options: {},
			});
		}
	},
});

const passwordSpecialCharacters: IItem[] = [
	{ id: 'yes', title: 'Ja', value: 'true', isChecked: false },
	{ id: 'no', title: 'Nej', value: 'false', isChecked: false },
];

const autoGeneratedPassword = computed({
	get: () => {
		return (
			props.field.fieldOptions.generatedPassword?.autoGeneratedPassword ??
			false
		);
	},
	set: (value: boolean) => {
		const generatedPassword = {
			autoGeneratedPassword: value,
			passwordLength:
				props.field.fieldOptions.generatedPassword?.passwordLength ??
				'',
			selectedPasswordSpecialCharacters:
				props.field.fieldOptions.generatedPassword
					?.selectedPasswordSpecialCharacters ??
				passwordSpecialCharacters[1],
		};

		const newFieldOptions = {
			...props.field.fieldOptions,
			generatedPassword,
		};

		if (value) {
			newFieldOptions.readOnly = true;
		}

		store.commit(MutationType.UpdateFormField, {
			fieldId: props.field.id,
			newValue: newFieldOptions,
			fieldProperty: 'fieldOptions',
		});
	},
});

const passwordLength = computed({
	get: () => {
		return props.field.fieldOptions.generatedPassword?.passwordLength ?? '';
	},
	set: (value: string) => {
		const generatedPassword = {
			autoGeneratedPassword:
				props.field.fieldOptions.generatedPassword
					.autoGeneratedPassword,
			passwordLength: value,
			selectedPasswordSpecialCharacters:
				props.field.fieldOptions.generatedPassword
					.selectedPasswordSpecialCharacters,
		};

		store.commit(MutationType.UpdateFormField, {
			fieldId: props.field.id,
			newValue: { ...props.field.fieldOptions, generatedPassword },
			fieldProperty: 'fieldOptions',
		});
	},
});

const selectedPasswordSpecialCharacters = computed({
	get: () => {
		return (
			props.field.fieldOptions.generatedPassword
				?.selectedPasswordSpecialCharacters?.id ?? ''
		);
	},
	set: (selectedItemId: string) => {
		const selectedPasswordSpecialCharacters =
			passwordSpecialCharacters.find(
				(option) => option.id === selectedItemId
			);
		if (selectedPasswordSpecialCharacters) {
			selectedPasswordSpecialCharacters.isChecked = true;

			const generatedPassword = {
				autoGeneratedPassword:
					props.field.fieldOptions.generatedPassword
						.autoGeneratedPassword,
				passwordLength:
					props.field.fieldOptions.generatedPassword.passwordLength,
				selectedPasswordSpecialCharacters:
					selectedPasswordSpecialCharacters,
			};

			store.commit(MutationType.UpdateFormField, {
				fieldId: props.field.id,
				newValue: { ...props.field.fieldOptions, generatedPassword },
				fieldProperty: 'fieldOptions',
			});
		}
	},
});
</script>
